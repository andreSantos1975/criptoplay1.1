generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String            @id @default(cuid())
  name                String?
  username            String?           @unique
  email               String?           @unique
  emailVerified       DateTime?
  image               String?
  password            String?
  isAdmin             Boolean           @default(false)
  virtualBalance      Decimal           @default(10000) @db.Decimal(12, 2)
  monthlyStartingBalance Decimal        @default(10000) @db.Decimal(12, 2)
  bankruptcyExpiryDate DateTime?
  createdAt           DateTime          @default(now())
  trialEndsAt         DateTime?
  isPublicProfile     Boolean           @default(true)
  chatMessageCount    Int               @default(0)
  lastChatMessageAt   DateTime?
  chatMessageLimit    Int               @default(30)
  passwordResetToken  String?           @unique
  passwordResetExpires DateTime?
  dailyPerformances   DailyPerformance[]
  monthlyRankings     MonthlyRanking[]
  oauthAccounts       OAuthAccount[]
  bankAccounts        BankAccount[]
  creditCards         CreditCard[]
  budgets             Budget[]
  BudgetCategory      BudgetCategory[]
  capitalMovements    CapitalMovement[]
  Contact             Contact[]
  expenses            Expense[]
  incomes             Income[]
  sessions            Session[]
  trades              Trade[]
  userProgress        UserProgress[]
  subscriptionStatus  String?           // e.g., "none", "active", "pending", "cancelled"
  subscriptions       Subscription[]
  alerts              Alert[]
  futuresPositions    FuturesPosition[]
}

model Subscription {
  id                      String    @id @default(cuid())
  userId                  String
  user                    User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  mercadoPagoSubscriptionId String? @unique
  status                  String    // e.g., "active", "pending", "paused", "cancelled"
  planId                  String?   // ID do plano (Mercado Pago, Hotmart, etc.)
  planName                String    // Nome do plano (ex: "Premium Mensal", "eBook XYZ")
  amount                  Decimal   @db.Decimal(12, 2)
  currency                String    @default("BRL")
  startDate               DateTime  @default(now())
  endDate                 DateTime? // Para acessos com tempo limitado
  type                    String    @default("RECURRING") // ex: RECURRING, LIFETIME
  origin                  String    @default("CRIPTONET") // ex: CRIPTONET, HOTMART
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt
}

model OAuthAccount {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model BankAccount {
  id        String          @id @default(cuid())
  userId    String
  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  name      String
  bankName  String
  balance   Decimal         @db.Decimal(18, 2)
  type      BankAccountType
  expenses  Expense[]

  @@index([userId])
}

model CreditCard {
  id              String    @id @default(cuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  name            String
  issuer          String
  creditLimit     Decimal   @db.Decimal(18, 2)
  availableCredit Decimal   @db.Decimal(18, 2)
  closingDay      Int
  dueDay          Int
  flag            CardFlag
  expenses        Expense[]

  @@index([userId])
}


model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Contact {
  id        Int      @id @default(autoincrement())
  name      String
  email     String
  subject   String
  message   String
  createdAt DateTime @default(now())
  userId    String?
  User      User?    @relation(fields: [userId], references: [id])
}

model Income {
  id          String   @id @default(cuid())
  userId      String
  description String
  amount      Decimal  @db.Decimal(18, 2)
  date        DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Expense {
  id             String   @id @default(cuid())
  userId         String
  categoria      String
  valor          Decimal  @db.Decimal(18, 2)
  originalValor  Decimal? @db.Decimal(18, 2)
  savedAmount    Decimal? @db.Decimal(18, 2)
  applySavingsCalculation Boolean  @default(false)
  dataVencimento DateTime
  status         String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  bankAccountId  String?
  bankAccount    BankAccount? @relation(fields: [bankAccountId], references: [id])
  creditCardId   String?
  creditCard     CreditCard?  @relation(fields: [creditCardId], references: [id])

  @@index([bankAccountId])
  @@index([creditCardId])
}

model Trade {
  id         String          @id @default(cuid())
  symbol     String
  type       String
  status     String          @default("OPEN")
  entryDate  DateTime
  exitDate   DateTime?
  entryPrice Decimal         @db.Decimal(18, 8)
  exitPrice  Decimal?        @db.Decimal(18, 8)
  quantity   Decimal         @db.Decimal(18, 8)
  stopLoss   Decimal         @db.Decimal(18, 8)
  takeProfit Decimal         @db.Decimal(18, 8)
  pnl        Decimal?        @db.Decimal(18, 8)
  pnlInBrl   Decimal?        @db.Decimal(18, 8)
  notes      String?
  sentiment  String?         // Ex: "CONFIDENT", "FEAR", "NEUTRAL"
  strategy   String?         // Ex: "BREAKOUT", "REVERSAL", "TREND"
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
  userId     String
  marketType TradeMarketType @default(SPOT)
  isSimulator Boolean         @default(false)
  user       User            @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model CapitalMovement {
  id          String              @id @default(cuid())
  userId      String
  amount      Decimal             @db.Decimal(18, 2)
  type        CapitalMovementType
  date        DateTime            @default(now())
  description String?
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  user        User                @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Budget {
  id     String       @id @default(cuid())
  userId String
  year   Int
  user   User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  items  BudgetItem[]

  @@unique([userId, year])
}

model BudgetItem {
  id         String         @id @default(cuid())
  budgetId   String
  categoryId String
  month      Int
  amount     Float
  budget     Budget         @relation(fields: [budgetId], references: [id], onDelete: Cascade)
  category   BudgetCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([budgetId, categoryId, month])
}

model BudgetCategory {
  id     String       @id @default(cuid())
  name   String
  type   String
  userId String
  User   User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  items  BudgetItem[]
}

model UserProgress {
  id        String   @id @default(cuid())
  userId    String
  slug      String
  completed Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, slug])
}

enum CapitalMovementType {
  DEPOSIT
  WITHDRAWAL
}

enum TradeMarketType {
  SPOT
  FUTURES
}

model DailyPerformance {
  id                  String   @id @default(cuid())
  userId              String
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  date                DateTime @db.Date
  startingBalance     Decimal  @db.Decimal(12, 2)
  endingBalance       Decimal  @db.Decimal(12, 2)
  totalPnl            Decimal  @default(0) @db.Decimal(12, 2)
  dailyPercentageGain Float
  totalTrades         Int      @default(0)
  winningTrades       Int      @default(0)

  @@unique([userId, date])
}

enum BankAccountType {
  CHECKING
  SAVINGS
}

enum CardFlag {
  VISA
  MASTERCARD
  AMEX
  ELO
  HIPERCARD
  OTHER
}

model Alert {
  id           String     @id @default(cuid())
  userId       String
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  type         AlertType
  config       Json
  status       AlertStatus @default(ACTIVE)
  triggeredAt  DateTime?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  @@index([userId, status])
}

enum AlertType {
  PRICE
  BUDGET
  BILL
}

enum AlertStatus {
  ACTIVE
  TRIGGERED
  ACKNOWLEDGED
  DELETED
  ERROR
}

model FuturesPosition {
  id               String           @id @default(cuid())
  userId           String
  user             User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  symbol           String
  side             PositionSide
  status           PositionStatus   @default(OPEN)
  quantity         Decimal          @db.Decimal(18, 8)
  leverage         Int
  entryPrice       Decimal          @db.Decimal(18, 8)
  liquidationPrice Decimal          @db.Decimal(18, 8)
  margin           Decimal          @db.Decimal(18, 8)
  stopLoss         Decimal?         @db.Decimal(18, 8)
  takeProfit       Decimal?         @db.Decimal(18, 8)
  pnl              Decimal?         @db.Decimal(18, 8)
  pnlInBrl         Decimal?         @db.Decimal(18, 8)
  notes            String?
  sentiment        String?          // Ex: "CONFIDENT", "FEAR", "NEUTRAL"
  strategy         String?          // Ex: "BREAKOUT", "REVERSAL", "TREND"
  closedAt         DateTime?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  @@index([userId, status])
}

enum PositionSide {
  LONG
  SHORT
}

enum PositionStatus {
  OPEN
  CLOSED
  LIQUIDATED
}

model MonthlyRanking {
  id             String   @id @default(cuid())
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  month          Int
  year           Int
  startingBalance Decimal @db.Decimal(12, 2)
  finalBalance   Decimal  @db.Decimal(12, 2)
  roiPercentage  Float
  rankPosition   Int
  createdAt      DateTime @default(now())

  @@unique([userId, month, year])
  @@index([month, year, rankPosition])
}

model HotmartPurchase {
  id         String   @id @default(cuid())
  buyerEmail String   @unique
  status     String   @default("PENDING") // PENDING, REDEEMED
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}